// string.paw

pub fn test_valid_utf8() {
    let s = "\u0060\u012a\u12AB";
    let s = "\uD801\udc37";
    let s = "\ud83d\ude39\ud83d\udc8d";
    let s = "\"\\\/\b\f\n\r\t\v";
    let s = "\\u0000";
    let s = "\"";
    let s = "a/*b*/c/*d//e";
    let s = "\\a";
    let s = "\\n";
    let s = "\u0012";
    let s = "\uFFFF";
    let s = "\uDBFF\uDFFF";
    let s = "new\u00A0line";
    let s = "ô¿¿";
    let s = "ï¿¿";
    let s = "\u0000";
    let s = "\u002c";
    let s = "Ï€";
    let s = "ğ›¿¿";
    let s = "\uD834\uDd1e";
    let s = "\u0821";
    let s = "\u0123";
    let s = "\u0061\u30af\u30EA\u30b9";
    let s = "new\u000Aline";
    let s = "\uA66D";
    let s = "\u005C";
    let s = "â‚ãˆ´â‚";
    let s = "\uDBFF\uDFFE";
    let s = "\uD83F\uDFFE";
    let s = "\u200B";
    let s = "\u2064";
    let s = "\uFDD0";
    let s = "\uFFFE";
    let s = "\u0022";
    let s = "â‚¬ğ„";
    let s = "ğŸ±";
}

pub fn test_starts_with() {
    let str = 'abcdef';
    assert(_string_starts_with(str, 'abcdef'));
    assert(_string_starts_with(str, 'abcde'));
    assert(_string_starts_with(str, 'abc'));
    assert(_string_starts_with(str, 'a'));
    assert(_string_starts_with(str, ''));
    assert(!_string_starts_with(str, 'bcdef'));
    assert(!_string_starts_with(str, 'abcdf'));
    assert(!_string_starts_with(str, 'abd'));
    assert(!_string_starts_with(str, 'ac'));
}

pub fn test_ends_with() {
    let str = 'abcdef';
    assert(_string_ends_with(str, 'abcdef'));
    assert(_string_ends_with(str, 'bcdef'));
    assert(_string_ends_with(str, 'def'));
    assert(_string_ends_with(str, 'f'));
    assert(_string_ends_with(str, ''));
    assert(!_string_ends_with(str, 'abcde'));
    assert(!_string_ends_with(str, 'acdef'));
    assert(!_string_ends_with(str, 'cef'));
    assert(!_string_ends_with(str, 'df'));
}

pub fn test_slices() {
    let s = 'abc';
    assert(s[:] == 'abc')    ;
    assert(s[0:#s] == 'abc')    ;

    assert(s[:-1] == 'ab');
    assert(s[:#s-1] == 'ab');
    assert(s[:-2] == 'a');
    assert(s[:#s-2] == 'a');
    assert(s[:-3] == '');
    assert(s[:#s-3] == '');

    assert(s[1:] == 'bc');
    assert(s[-2:] == 'bc');
    assert(s[2:] == 'c');
    assert(s[-1:] == 'c');
    assert(s[3:] == '');
    assert(s[0:0] == '') ;
}

pub fn test_find() {
    let check = |s, sub, n| {
        assert(n == _string_find(s, sub));
    };
    check('abc', 'a', 0);
    check('abc', 'b', 1);
    check('abc', 'c', 2);
    check('abc', 'd', -1);
}

pub fn test_split_and_join() {
    let check = |s, sep, parts: [str]| {
        let a = _string_split(s, sep);
        for i = 0, #a {
            assert(a[i] == parts[i]);
        };
        assert(#a == #parts);
        let result = _string_join(sep, a);
        assert(result == s);
    };
    check('abc', 'a', ['', 'bc']);
    check('abc', 'b', ['a', 'c']);
    check('abc', 'c', ['ab', '']);
    check('abc', 'd', ['abc']);

    let s = ',a,,b,,,c,,,,d,,,,,e,,,,,,';
    let a = _string_split(s, ',');
    assert(_string_join('', a) == 'abcde');
}

