// basic.paw

{
    // line comment
    /* block comment */
    /* multi-line
       block
       comment */
    /* /* */
    /* * / */

    // 2 block comments, side-by-side
    /**//**/
    /* *//* */
    /**/ /**/
}

{
    // Semicolons are not necessary in most cases.
    let x: int = 0 x = 1 + 2 + 3 assert(x == 6)
    x = 1 - 2 - 3 x = 4 + 5 + 6 assert(x == 15)    
}

{
    fn wrapper(n: int, f: fn(int) -> int) -> int {
        return f(n)
    }
    fn f1(n: int) -> int {
        return n
    }
    fn f2(n: int) -> int {
        fn f(n: int) -> int {
            return n
        }
        return f(n)
    }
    fn f3(n: int) -> int {
        fn f(n: int) -> fn() -> int {
            fn f() -> int {
                return n
            }
            return f
        }
        return f(n)()
    }
    assert(1 == wrapper(1, f1))
    assert(2 == wrapper(2, f2))
    assert(3 == wrapper(3, f3))
}

{
    let x: int = 0
    {;;;};;;{};;;
    {; x = 1; assert(x == 1)}
}

{
    fn f() {}
    f()
    fn f() {return}
    f()

    fn f() -> int {let x: int = 0; return x}
    assert(f() == 0)

    fn f(x: int) -> int {return x}
    assert(f(1) == 1)

    fn f(x: int, y: int) -> int {return x}
    assert(f(0, 1) == 0)
    fn f(x: int, y: int) -> int {return y}
    assert(f(0, 1) == 1)

    fn f(x: int, y: int, z: int) -> int {return x}
    assert(f(0, 1, 2) == 0)
    fn f(x: int, y: int, z: int) -> int {return y}
    assert(f(0, 1, 2) == 1)
    fn f(x: int, y: int, z: int) -> int {return z}
    assert(f(0, 1, 2) == 2)
}

{
    fn f() -> int {
        {
            // Return statement must be the last statement in the block.
            return 42
        }
        return 24 // unreachable
    }
    assert(f() == 42)
}

// String literals: both types of quotes are okay, and strings can span 
// multiple lines.
{
    assert('abc' == "abc");
    assert('abc\n def\n ghi\n\n' == 'abc
 def
 ghi

')

}

// Short-circuiting behavior:
{
    let counts = (0, 0, 0)
    fn check2(a: int, b: int) {
        assert(counts.0 == a)
        assert(counts.1 == b)
        counts.0 = 0
        counts.1 = 0
    }
    fn A(value: int) -> bool {
        counts.0 = counts.0 + 1
        return bool(value)
    }
    fn B(value: int) -> bool {
        counts.1 = counts.1 + 1
        return bool(value)
    }
    fn C(value: int) -> bool {
        counts.2 = counts.2 + 1
        return bool(value)
    }

    fn or(a: int, b: int) -> bool {
        return A(a) || B(b)
    }
    assert(!or(0, 0))
    check2(1, 1)
    assert(or(0, 1))
    check2(1, 1)
    assert(or(1, 0))
    check2(1, 0)
    assert(or(1, 1))
    check2(1, 0)

    fn and(a: int, b: int) -> bool {
        return A(a) && B(b)
    }
    assert(!and(0, 0))
    check2(1, 0)
    assert(!and(0, 1))
    check2(1, 0)
    assert(!and(1, 0))
    check2(1, 1)
    assert(and(1, 1))
    check2(1, 1)

    fn check3(a: int, b: int, c: int) {
        check2(a, b)
        assert(counts.2 == c)
        counts.2 = 0
    }

    fn and_or(a: int, b: int, c: int) -> bool {
        return A(a) && B(b) || C(c)
    }
    assert(!and_or(0, 0, 0))
    check3(1, 0, 1)
    assert(!and_or(1, 0, 0))
    check3(1, 1, 1)
    assert(!and_or(0, 1, 0))
    check3(1, 0, 1)
    assert(and_or(0, 0, 1))
    check3(1, 0, 1)
    assert(and_or(1, 1, 0))
    check3(1, 1, 0)
    assert(and_or(0, 1, 1))
    check3(1, 0, 1)
    assert(and_or(1, 0, 1))
    check3(1, 1, 1)
    assert(and_or(1, 1, 1))
    check3(1, 1, 0)
}

{
    struct C {
        val: int
        get: fn() -> fn() -> C
    }
    fn get() -> fn() -> C {
        fn inner() -> C {return C{get: get, val: 123}}
        return inner
    }
    let c = C{get: get, val: 0}
    let v = Vector[C]{c}

    v[0].val = 42
    v[0].get()().val = 0
    assert(v[0].val == 42)
    assert(v[0].get()().val == 123)
}

//{
//    let v = [0, 1, 2][1]
//    assert(v == 1)
//    let m = {0: 0, 1: 1, 2: 2}[1]
//    assert(m == 1)
//}

{
    let s = ''
    for a = 0, 1 {
        s = s + 'a'
        for b = 0, 2 {
            s = 'b' + s
            for c = 0, 3 {
                s = 'c' + s + 'd'
            }
        }
    }
    assert(s == 'cccbcccbadddddd')
}

// Chain ('?') expressions:
{
    fn opt(b: bool) -> Option[int] {
        if b {
            return Option[int]::Some(1)
        } else {
            return Option[int]::None()
        }
    }

    {
        let hit = false
        fn test() -> Option[int] {
            let o = opt(true)?
            hit = true
            return o
        }
        test()
        assert(hit)
    }

    {
        fn test() -> Option[int] {
            let o = opt(false)?
            assert(false)
            return o
        }
        test()
    }

    fn opt[T](b: bool, v: T) -> Option[T] {
        if b {
            return Option[T]::Some(v)
        } else {
            return Option[T]::None()
        }
    }

    {
        fn test[T](v: T) -> Option[T] {
            let o = opt(false, v)?
            assert(false)
            return o
        }
        test(123)
        test('abc')
    }

    fn res(b: bool) -> Result[int, string] {
        if b {
            return Result[int, string]::Ok(42)
        } else {
            return Result[int, string]::Err('bad')
        }
    }

    {
        let hit = false
        fn test() -> Result[int, string] {
            let r = res(true)?
            hit = true
            return r
        }
        test()
        assert(hit)
    }

    {
        fn test() -> Result[int, string] {
            let r = res(false)?
            assert(false)
            return r
        }
        test()
    }

}
