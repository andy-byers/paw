// basic.paw

{
    // line comment
    /* block comment */
    /* multi-line
       block
       comment */
    /* /* */
    /* * / */

    // 2 block comments, side-by-side
    /**//**/
    /* *//* */
    /**/ /**/
}

{
    // Semicolons are not necessary in most cases.
    let x: int = 0 x = 1 + 2 + 3 assert(x == 6)
    x = 1 - 2 - 3 x = 4 + 5 + 6 assert(x == 15)    
}

{
    fn wrapper(n: int, f: fn(int) -> int) -> int {
        return f(n)
    }
    fn f1(n: int) -> int {
        return n
    }
    fn f2(n: int) -> int {
        fn f(n: int) -> int {
            return n
        }
        return f(n)
    }
    fn f3(n: int) -> int {
        fn f(n: int) -> fn() -> int {
            return || -> int {
                return n
            }
        }
        return f(n)()
    }
    assert(1 == wrapper(1, f1))
    assert(2 == wrapper(2, f2))
    assert(3 == wrapper(3, f3))
}

{
    let x: int = 0
    {;;;};;;{};;;
    {; x = 1; assert(x == 1)}
}

{
    fn f() {}
    f()
    fn f() {return}
    f()

    fn f() -> int {let x: int = 0; return x}
    assert(f() == 0)

    fn f(x: int) -> int {return x}
    assert(f(1) == 1)

    fn f(x: int, y: int) -> int {return x}
    assert(f(0, 1) == 0)
    fn f(x: int, y: int) -> int {return y}
    assert(f(0, 1) == 1)

    fn f(x: int, y: int, z: int) -> int {return x}
    assert(f(0, 1, 2) == 0)
    fn f(x: int, y: int, z: int) -> int {return y}
    assert(f(0, 1, 2) == 1)
    fn f(x: int, y: int, z: int) -> int {return z}
    assert(f(0, 1, 2) == 2)
}

{
    fn f() -> int {
        {
            // Return statement must be the last statement in the block.
            return 42
        }
        return 24 // unreachable
    }
    assert(f() == 42)
}

// String literals: both types of quotes are okay, and strings can span 
// multiple lines.
{
    assert('abc' == "abc");
    assert('abc\n def\n ghi\n\n' == 'abc
 def
 ghi

')

}

// Short-circuiting behavior:
{
    let counts = (0, 0, 0)
    let check2 = |a: int, b: int| {
        assert(counts.0 == a)
        assert(counts.1 == b)
        counts.0 = 0
        counts.1 = 0
    }
    let A = |value: int| -> bool {
        counts.0 = counts.0 + 1
        return value as bool
    }
    let B = |value: int| -> bool {
        counts.1 = counts.1 + 1
        return value as bool
    }
    let C = |value: int| -> bool {
        counts.2 = counts.2 + 1
        return value as bool
    }

    let or = |a: int, b: int| -> bool {
        return A(a) || B(b)
    }
    assert(!or(0, 0))
    check2(1, 1)
    assert(or(0, 1))
    check2(1, 1)
    assert(or(1, 0))
    check2(1, 0)
    assert(or(1, 1))
    check2(1, 0)

    let and = |a: int, b: int| -> bool {
        return A(a) && B(b)
    }
    assert(!and(0, 0))
    check2(1, 0)
    assert(!and(0, 1))
    check2(1, 0)
    assert(!and(1, 0))
    check2(1, 1)
    assert(and(1, 1))
    check2(1, 1)

    let check3 = |a: int, b: int, c: int| {
        check2(a, b)
        assert(counts.2 == c)
        counts.2 = 0
    }

    let and_or = |a: int, b: int, c: int| -> bool {
        return A(a) && B(b) || C(c)
    }
    assert(!and_or(0, 0, 0))
    check3(1, 0, 1)
    assert(!and_or(1, 0, 0))
    check3(1, 1, 1)
    assert(!and_or(0, 1, 0))
    check3(1, 0, 1)
    assert(and_or(0, 0, 1))
    check3(1, 0, 1)
    assert(and_or(1, 1, 0))
    check3(1, 1, 0)
    assert(and_or(0, 1, 1))
    check3(1, 0, 1)
    assert(and_or(1, 0, 1))
    check3(1, 1, 1)
    assert(and_or(1, 1, 1))
    check3(1, 1, 0)
}

{
    struct C {
        val: int
        get: fn() -> fn() -> C
    }
    fn get() -> fn() -> C {
        let inner = || -> C {
            return C{get: get, val: 123}
        }
        return inner
    }
    let c = C{get: get, val: 0}
    let v = [c]

    v[0].val = 42
    v[0].get()().val = 0
    assert(v[0].val == 42)
    assert(v[0].get()().val == 123)
}

{
    let v = [0, 1, 2][1]
    assert(v == 1)
    let m = [0: 0, 1: 1, 2: 2][1]
    assert(m == 1)
}

{
    let s = ''
    for a = 0, 1 {
        s = s + 'a'
        for b = 0, 2 {
            s = 'b' + s
            for c = 0, 3 {
                s = 'c' + s + 'd'
            }
        }
    }
    assert(s == 'cccbcccbadddddd')
}

// Chain ('?') expressions:
{
    fn opt(b: bool) -> Option<int> {
        if b {
            return Option::<int>::Some(42)
        } else {
            return Option::<int>::None
        }
    }

    {
        let val = -1
        let test = || -> Option<int> {
            let i = opt(true)?
            val = i
            return Option::<int>::Some(i)
        }
        test()
        assert(val == 42)
    }

    {
        let test = || -> Option<int> {
            let i = opt(false)?
            assert(false)
            return Option::<int>::Some(i)
        }
        test()
    }

    {
        let test = |o: Option<int>| {}    
        test(Option::<int>::Some(123))
        test(Option::<int>::None)
    }

    fn opt<T>(b: bool, v: T) -> Option<T> {
        if b {
            return Option::<T>::Some(v)
        } else {
            return Option::<T>::None
        }
    }

    {
        fn test<T>(v: T) -> Option<T> {
            let t = opt(false, v)?
            assert(false)
            return Option::<T>::Some(t)
        }
        test(123)
        test('abc')
    }

    fn res(b: bool) -> Result<int, string> {
        if b {
            return Result::<int, string>::Ok(42)
        } else {
            return Result::<int, string>::Err('bad')
        }
    }

    {
        let val = -1
        let test = || -> Result<int, string> {
            let i = res(true)?
            val = i
            return Result::<int, string>::Ok(i)
        }
        test()
        assert(val == 42)
    }

    {
        let test = || -> Result<int, string> {
            let i = res(false)?
            assert(false)
            return Result::<int, string>::Ok(i)
        }
        test()
    }

    {
        struct Inner<T> {
            val: T
        }
        struct Outer<T> {
            opt: Option<Inner<T>>
        }
        fn opt<T>(t: T, a: bool, b: bool) -> Option<Outer<T>> {
            if a {
                if b {
                    return Option::<Outer<T>>::Some(Outer::<T>{
                        opt: Option::<Inner<T>>::Some(Inner::<T>{val: t}),
                    })
                } else {
                    return Option::<Outer<T>>::Some(Outer::<T>{
                        opt: Option::<Inner<T>>::None,
                    })
                }
            } else {
                return Option::<Outer<T>>::None
            }
        }
        opt(42, true, true)
        opt(42, true, false)
        opt(42, false, false)
    }
}

// TODO: move to integer.paw (still needs to be fixed)
{
    assert(1 << 0 == 1)
    assert(-1 << 0 == -1)

    let imin = -0x7FFFFFFFFFFFFFFF - 1
    let imax = 0x7FFFFFFFFFFFFFFF
    assert(imax == -(imin + 1))
    assert(imin == -imax - 1)

    assert(imin == -9223372036854775807 - 1)
    assert(imax == 9223372036854775807)
}

