// types.paw

//class A {
//    a: int
//    b: float
//
//    c() {
//        print('A.c()\n')
//    }
//}
//
//let a: A = A {
//    .a = 1,
//    .b = 2,
//}

fn recursion(n: int) -> int {
    if n > 2 {
        print('recursion!\n')
        return recursion(n - 1)
    }
    return 0
}
recursion(15)

//***********************************************
//    primitives
//***********************************************
{
    // test type annotations
    let i: int = 123
    let s: string = 'abc'
    let b: bool = true
    let f: float = 1.0

    // test inferred types
    let I = 123
    let S = 'abc'
    let B = true
    let F = 1.0

    assert(i == I)
    assert(s == S)
    assert(b == B)
    assert(f == F)
}

//***********************************************
//    functions
//***********************************************
{
    fn f() {
        // implicit 'return'
    }
    fn fi(a: int) {
        return
    }
    f()
    fi(1)

    // test 'int' annotation
    fn f_i() -> int {
        return 1
    }
    fn fi_i(a: int) -> int {
        return a + 2
    }
    fn fii_i(a: int, b: int) -> int {
        return a + b + 3
    }
    f_i()
    fi_i(1)
    fii_i(1, 2)

    let f: fn(int, int) -> int = fii_i
    f(1, 2)

    let f = fii_i
    f(3, 4)
}

////***********************************************
////    classes
////***********************************************
//{
////    class A {}
////    let a: A = A()
//}
//
////***********************************************
////    arrays
////***********************************************
//{
////    // empty arrays
////    let a1: [int]
////    let a2: [[int]]
////    let a3: [[[int]]]
////    assert(#a1 == 0)
////    assert(#a2 == 0)
////    assert(#a3 == 0)
////
////    let a1: [int] = [1]
////    let a2: [[int]] = [[1], [2]]
////    let a3: [[[int]]] = [[[1]], [[2]], [[3]]]
////
////    let a1 = [1]
////    let a2 = [[1], [2]]
////    let a3 = [[[1]], [[2]], [[3]]]
////
////    let a = [[[], []], [], [[3]]]
////
////    let a: [[int]] = []
////    let a: [[int]] = []
//}
//
//// TODO: move to class.paw
////{
////    class A {
////        a: A
////    }           // a: 0
////    let a = A() // a: 1
////    a.a = a     // a: 2
////}               // a: 1
