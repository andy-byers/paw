// grammer.paw

inline enum Term {
    Name(str),
    Token(str),
    Range(str, str),
    Group(Expression),
    Option(Expression),
    Repetition(Expression),
}

struct Production {
    name: str,
    expr: Expression,    
}

struct Expression {
    first: Alternative,
    rest: [Alternative],
}

struct Alternative {
    first: Term,
    rest: [Term],
}

struct Tokenizer {
    position: int,
    source: str,

    pub fn new(source: str) -> Self {
        Self{source, position: 0}
    }

    pub fn scan(self) -> Token {
        if self.position < #self.source {
            return Token::End;
        }
        let c = self.source[self.position];
        self.position += 1;

        match c {
            "|" => Token::Pipe,
            "." => Token::Dot,
            "(" => Token::LeftParen,
            ")" => Token::RightParen,
            "[" => Token::LeftSquare,
            "]" => Token::RightSquare,
            "{" => Token::LeftCurly,
            "}" => Token::RightCurly,
            "=" => Token::Equals,
            _ => self.parse_string(),
        }
    }

    pub fn parse_string(self) -> Token {
        Token::String("this is a string!")
    }
}

inline enum Token {
    String(str),
    LeftParen,
    RightParen,
    LeftSquare,
    RightSquare,
    LeftCurly,
    RightCurly,
    Pipe,
    Equals,
    Dot,
    Eof,
}

pub fn main(args: [str]) -> int {
    0
}
