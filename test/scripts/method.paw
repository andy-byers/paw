// method.paw

// TODO: Fix this
fn fix_list() {
    print('TODO: fix ADT instantiation inside polymorphic function not creating methods\n');
    let list = [];
    list.push(123);
    list.pop();
    list.length();
}

pub fn test_list_methods() {
    let list = [1, 3, 5, -20, -10];
    assert(list.length() == 5);

    list.insert(2, 4);
    list.insert(1, 2);
    assert(list.remove(-2) == -20); 
    assert(list.remove(-1) == -10); 
    list.push(6);

    for i = 6, 0, -1 {
        assert(list.pop() == i);
    }
    assert(list.length() == 0);
}

struct Stack<T> {
    ts: [T]
}

impl<T> Stack<T> {
    pub fn push(t: T) {
        self.ts.push(t);
    }

    pub fn pop() -> T {
        return self.ts.pop();
    }

    pub fn is_empty() -> bool {
        return self.ts.length() == 0;
    }
}

pub fn test_calls() {
    let outer = Stack::<Stack<int>>{ts: []};

    let N = 100;
    for i = 0, N {
        let inner = Stack::<int>{ts: []};
        outer.push(inner);
        for j = 0, N {
            inner.push(i * N + j);
        }
    }
    assert(outer.ts[0].ts[0] == 0 * N + 0);
    assert(outer.ts[11].ts[11] == 11 * N + 11);
    assert(outer.ts[99].ts[99] == 99 * N + 99);

    while !outer.is_empty() {
        let inner = outer.ts[-1];
        while !inner.is_empty() {
            inner.pop();
        }
        outer.pop();
    }
}

struct Mono {
    value: int
}

impl Mono {
    pub fn noop() {}

    pub fn access_field() -> int {
        return self.value;
    }

    pub fn call_method() -> int {
        return self.access_field();
    }

    pub fn recursion(count: int) -> int {
        if self.value > 0 {
            self.value = self.value - 1;
            return self.recursion(count + 1);
        }
        return count;
    }

    pub fn mutual_recursion(count: int) -> int {
        if self.value > 0 {
            return self.mutual_recursion_2(count);
        }
        return count;
    }

    pub fn mutual_recursion_2(count: int) -> int {
        self.value = self.value - 1;
        return self.mutual_recursion(count + 1);
    }
}

// same name as method
fn noop() {
    assert(false);
}

pub fn test_mono_impl() {
    let m = Mono{value: 42};

    m.noop();
    assert(m.access_field() == 42);
    assert(m.call_method() == 42);

    m.value = 10;
    assert(m.recursion(0) == 10);
    assert(m.recursion(1) == 1);

    m.value = 100;
    assert(m.mutual_recursion(0) == 100);
    assert(m.mutual_recursion(1) == 1);
}

struct Poly<T> {
    value: T
}

impl<T> Poly<T> { 
    fn method() -> T {
        return self.value;
    }
}

impl Poly<str> {
    fn str_only() -> str {
        return self.value;
    }
}

impl Poly<int> {
    // signatures differ between Poly<int> and Poly<float>
    pub fn different_signatures() -> int {
        return self.value;
    }

    // Poly<int> and Poly<float> have idential signatures
    pub fn same_signatures() -> int {
        return self.different_signatures();
    }
}

impl Poly<float> {
    pub fn different_signatures() -> float {
        return self.value;
    }

    pub fn same_signatures() -> int {
        let p = Poly{value: 42};
        return p.different_signatures();
    }
}

pub fn test_poly_impl() {
    let e = Poly{value: 42};
    e.method();

    let e = Poly{value: 'abc'};
    e.str_only();

    let e = Poly{value: 42};
    assert(e.different_signatures() == 42);
    assert(e.same_signatures() == 42);

    let e = Poly{value: 1.0};
    assert(e.different_signatures() == 1.0);
    assert(e.same_signatures() == 42);
}

struct Poly2<A, B> {
    a: A,
    b: B,
}

impl<X, Y> Poly2<Y, X> {
    pub fn f(a: X) -> Y {
        self.b = a;
        return self.a;
    }
}

impl Poly2<int, int> {
    pub fn to_str() -> str {
        return 'Poly2{' + self.a.to_string() + ', ' +
                          self.b.to_string() + '}';
    }
}
impl Poly2<bool, str> {
    pub fn to_str() -> str {
        return 'Poly2{' + self.a.to_string() + ', "' +
                          self.b + '"}';
    }
}

impl<T> Poly2<T, T> {
    pub fn swap() {
        let t = self.a;
        self.a = self.b;
        self.b = t;
    }
}

impl<T> Poly2<Aux<T>, Aux<int>> {
    pub fn g(a: Aux<T>, scale: int) -> int {
        self.a = a;
        return self.b.value * scale;
    }
}

struct Aux<T> {
    value: T
}

pub fn test_poly_impl_2() {
    // A = bool, B = int
    let p = Poly2{
        a: true,
        b: 42,
    };
    // Unifies 'p' (Poly2<A, B>) with the instantiation of Poly2 (Poly2<Y, X>)
    // created by substituting the generic parameters from the impl block.
    // This yields the following concrete types:
    //     Y = A = bool
    //     X = B = int
    assert(p.f(123) == true &&
           p.b == 123);

    let p = Poly2{a: 1, b: 2};
    assert(p.to_str() == 'Poly2{1, 2}');
    p.swap();
    assert(p.to_str() == 'Poly2{2, 1}');

    let p = Poly2{a: true, b: 'two'};
    assert(p.to_str() == 'Poly2{true, "two"}');

    let p = Poly2{
        a: Aux{value: 1},
        b: Aux{value: 2},
    };
    assert(p.g(Aux{value: 3}, 10) == 20);
    assert(p.a.value == 3);
    p.swap();
    assert(p.a.value == 2);
}

impl int {
    pub fn user_defined() -> int {
        return self;
    }
}

impl<T> Poly<T> { 
    fn method2() -> [T] {
        return [self.value];
    }
}

pub fn test_multiple_impl_blocks() {
    let i = 42;
    assert(i.user_defined() == 42);
    assert(i.to_string() == '42');

    let p = Poly{value: 1.0};
    assert(p.method() == 1.0);
    assert(p.method2()[0] == 1.0);
}


