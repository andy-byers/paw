// method.paw

struct Struct {
    value: int,

    pub fn new(value: int) -> Self {
        Self{value}
    }

    pub fn get(self) -> int {
        self.value
    }
}

pub fn test_struct_methods() {
    let x = Struct::new(123);
    assert(x.get() == 123);
}

struct PolyStruct<Ty> {
    value: Ty,

    pub fn new(value: Ty) -> Self {
        Self{value}
    }

    pub fn get(self) -> Ty {
        self.value
    }
}

pub fn test_poly_struct_methods() {
    let x = PolyStruct::new(1.23);
    assert(x.get() == 1.23);
}

fn call_poly_struct_methods<T>(value: T) -> T {
    PolyStruct::new(value).get()
}

pub fn test_poly_struct_methods_indirect() {
    assert(call_poly_struct_methods("abc") == "abc");
}

enum Enum {
    A(int),
    B(str),

    pub fn new_a(value: int) -> Self {
        Self::A(value)
    }

    pub fn new_b(value: str) -> Self {
        Self::B(value)
    }

    pub fn debug(self) -> str {
        match self {
            Self::A(a) => "A(" + a.to_string() + ")",
            Self::B(b) => "B(" + b + ")",
        }
    }
}

pub fn test_enum_methods() {
    let x = Enum::new_a(123);
    assert(x.debug() == "A(123)");

    let x = Enum::new_b("abc");
    assert(x.debug() == "B(abc)");
}

enum PolyEnum<A, B> {
    A(A),
    B(B),

    pub fn new_a(value: A) -> Self {
        Self::A(value)
    }

    pub fn new_b(value: B) -> Self {
        Self::B(value)
    }

    pub fn get_a(self, b: B) -> Result<A, B> {
        match self {
            Self::A(a) => Result::Ok(a),
            Self::B(_) => Result::Err(b),
        }
    }

    pub fn get_b(self, a: A) -> Result<B, A> {
        match self {
            Self::A(_) => Result::Err(a),
            Self::B(b) => Result::Ok(b),
        }
    }
}

pub fn test_poly_enum_methods() {
    // type of B inferred from default provided to "get_a" below
    let x = PolyEnum::new_a(1.23);
    assert(x.get_a(456).unwrap() == 1.23);
    assert(x.get_b(4.56).unwrap_err() == 4.56);

    // type of A inferred from default provided to "get_b" below
    let x = PolyEnum::new_b(true);
    assert(x.get_b("abc").unwrap());
    assert(!x.get_a(false).unwrap_err());
}

fn call_poly_enum_methods<A, B>(a: A, b: B) -> A {
    let x = PolyEnum::new_a(a);
    x.get_a(b).unwrap()
}

pub fn test_poly_enum_methods_indirect() {
    assert(call_poly_enum_methods(123, "abc") == 123);
}
