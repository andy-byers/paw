// chain.paw

pub fn test_option() {
    let positive = |i: int| -> Option<int> {
        if i > 0 { 
            Some(i) 
        } else { 
            None 
        }
    };

    let positive_even = |i: int| -> Option<int> {
        i = positive(i)?;
        if i % 2 == 0 { 
            Some(i) 
        } else { 
            None 
        }
    };

    assert(positive_even(-2).is_none());
    assert(positive_even(1).is_none());
    assert(positive_even(2).unwrap() == 2);
}

pub fn test_result() {
    let positive = |i: int| -> Result<int, str> {
        if i > 0 { 
            Ok(i) 
        } else { 
            Err("not positive") 
        }
    };

    let positive_even = |i: int| -> Result<int, str> {
        i = positive(i)?;
        if i % 2 == 0 { 
            Ok(i) 
        } else { 
            Err("not even")
        }
    };

    assert(positive_even(-2).unwrap_err() == "not positive");
    assert(positive_even(1).unwrap_err() == "not even");
    assert(positive_even(2).unwrap() == 2);
}

struct Padding;

inline struct Padded<T> {
    pub padding: Padding,
    pub padding2: Padding,
    pub value: T,

    pub fn new(value: T) -> Self {
        Self{value, padding: Padding, padding2: Padding}
    }
}

pub fn test_different_option() {
    let positive = |p: Padded<int>| -> Option<Padded<int>> {
        if p.value > 0 { 
            Some(p) 
        } else { 
            None 
        }
    };

    assert(positive(Padded::new(-2)).is_none());

    let positive_even = |p: Padded<int>| -> Option<int> {
        p = positive(p)?;
        if p.value % 2 == 0 { 
            Some(p.value) 
        } else { 
            None 
        }
    };

    assert(positive_even(Padded::new(-2)).is_none());
    assert(positive_even(Padded::new(1)).is_none());
    assert(positive_even(Padded::new(2)).unwrap() == 2);
}

pub fn test_different_result() {
    let positive = |p: Padded<int>| -> Result<Padded<int>, str> {
        if p.value > 0 { 
            Ok(p) 
        } else { 
            Err("not positive") 
        }
    };

    let positive_even = |p: Padded<int>| -> Result<int, str> {
        p = positive(p)?;
        if p.value % 2 == 0 { 
            Ok(p.value) 
        } else { 
            Err("not even")
        }
    };

    assert(positive_even(Padded::new(-2)).unwrap_err() == "not positive");
    assert(positive_even(Padded::new(1)).unwrap_err() == "not even");
    assert(positive_even(Padded::new(2)).unwrap() == 2);
}

fn chain_stack_value(i: int) -> Option<int> {
    let id = |value| value;
    let f = |value: int| {
        if value < 0 { return None }
        Some(value)
    };

    // Here, the result of a function call ("f(i)") is passed to the "?" operator and
    // then immediately passed to another function. Requires a "MOVE" to overwrite
    // the discriminator after the "?" and before the call to "id". At the MIR level,
    // this move is a stack-to-stack move. It works because the lifetimes of both the
    // discriminator (part of the "Option<int>" returned by "f") and the old stack
    // slot end before the call to "id". 
    //
    //    stack      | source location
    //   ------------|----------------------------------
    //    .. id f i  | before call to "f" 
    //    .. id D i  | before "?" ("D" = discriminator)
    //    .. id i    | before call to "id" 
    //
    Some(id(f(i)?))
}

pub fn test_chain_stack_value() {
    assert(chain_stack_value(-1).is_none());
    assert(chain_stack_value(1).unwrap() == 1);
}
