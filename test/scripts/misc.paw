#!/usr/bin/env paw
// misc.paw

// TODO: try(), or some other error handling mechanism, and 'import'
//fn test_try_1() {
//    fn test(a, b, c, d, e) {
//        fn fa() {
//            let _1
//            fn fb() {
//                let _1
//                let _2
//                fn fc() {
//                    let _1
//                    let _2
//                    let _3
//                    fn fd() {
//                        let _1
//                        let _2
//                        let _3
//                        let _4
//                        return 1 / e
//                    }
//                    return fd() / d
//                }
//                return fc() / c
//            }
//            return fb() / b
//        }
//        return fa() / a
//    }
//    assert(0 == try(test, 1, 1, 1, 1, 1))
//    assert(0 != try(test, 0, 1, 1, 1, 1))
//    assert(0 != try(test, 1, 0, 1, 1, 1))
//    assert(0 != try(test, 1, 1, 0, 1, 1))
//    assert(0 != try(test, 1, 1, 1, 0, 1))
//    assert(0 != try(test, 1, 1, 1, 1, 0))
//}
//
//fn test_try_2() {
//    let test = |i| 1 / i 
//    assert(try(test, 0) != 0)
//    assert(try(test, 1) == 0)
//}
//
//fn test_basic_io() {
//    let io = require('io')
//    let file = io.open('./paw_test_data_', 'w+')
//    let input = 'Hello, world'
//    io.write(file, 'Hello')
//    io.write(file, ', ')
//    io.write(file, 'world!')
//    io.seek(file, 0, io.begin)
//    assert(io.tell(file) == 0)
//    let msg = io.read(file, #input)
//
//    assert(msg == input)
//    io.close(file)
//}

pub fn test_ackermann() {
    let ack = |m, n| {
        let stack = [m, n]
        while #stack > 1 {
            n = stack.pop()
            m = stack.pop()
            if m == 0 {
                _vector_push(stack, n + 1)
            } else if m == 1 {
                _vector_push(stack, n + 2)
            } else if m == 2 {
                _vector_push(stack, 2 * n + 3)
            } else if m == 3 {
                _vector_push(stack, (1 << (n + 3)) - 3)
            } else if n == 0 {
                _vector_push(stack, m - 1, 1)
            } else {
                _vector_push(stack, m - 1, m, n - 1)
            }
        }
        return stack[0]
    }
    assert(1 == ack(0, 0))
    assert(125 == ack(3, 4))
    assert(1 == ack(0, 0))
    assert(125 == ack(3, 4))
}

