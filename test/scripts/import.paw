// import.paw

fn call_test(k: str) {
    let f = mod_a::get_test(k);
    f();
}

pub fn test_import() {
    assert(mod_a::return_42() == 42);

    call_test('external');
    call_test('recursive');
}

// imported symbols are available anywhere in this module
use mod_a;

pub fn test_object() {
    let o = mod_a::Obj::new(true);
    assert(o.get_t());
}

use mod_a::poly_recursive;

pub fn test_specific_import() {
    let list = [];
    let count = poly_recursive(5, 123, list);
    assert(#list == 5);
    assert(list[-1] == 123);
}

pub fn test_star_import() {
    let c = choose(true);   
    assert(c == "abc");
    let c = choose(false);   
    assert(c == "def");
}

use mod_c::*;

//struct Aliased;
//
//pub fn test_alias() {
////    type I = int;
////    let i: I = 123;
//
//    type A = Aliased;
////    let a: A = Aliased;
////    let a: Aliased = A;
////    let a: A = A;
//    let a = A;
//}

pub enum Choice {
    First,
    Second,
}

// TODO: Use Self::First and Self::Second
//       Doesn't work currently: type checker says it can't perform "::" access on a local 
//       ("Self"). Should be allowed on a TypeDecl.
impl Choice {
    pub fn choose(b: bool) -> Self {
        if b { Choice::First }
        else { Choice::Second }
    }
}

fn choice_to_int(c: Choice) -> int {
    match c {
        Choice::First => 1,
        Choice::Second => 2,
    }
}

pub fn test_choice() {
    assert(choice_to_int(Choice::choose(true)) == 1);
    assert(choice_to_int(Choice::choose(false)) == 2);
}
