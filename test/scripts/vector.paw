// vector.paw

{
    let vec: [int] = []
    assert(0 == #vec)

    let vec: [int] = [1]
    assert(1 == #vec)

    let vec: [int] = [1, 2]
    assert(2 == #vec)

    let vec: [int] = [1, 2, 3]
    assert(3 == #vec)
}
{
    let vec = [1]
    assert(1 == #vec)

    let vec = [1, 2]
    assert(2 == #vec)

    let vec = [1, 2, 3]
    assert(3 == #vec)
}
{
    let vec = [false]
    let vec = [1.0, 2.0]
    let vec = ['three', 'four', 'five']
}
{
    let vec = [1, 2, 3]
    assert(1 == vec[0])
    assert(2 == vec[1])
    assert(3 == vec[2])
    assert(1 == vec[-3])
    assert(2 == vec[-2])
    assert(3 == vec[-1])
}
{
    let vec = [[1]]
    assert(1 == #vec)
    assert(1 == #vec[0])
    assert(1 == vec[0][0])
    let vec = [[[2]]]
    assert(1 == #vec)
    assert(1 == #vec[0])
    assert(1 == #vec[0][0])
    assert(2 == vec[0][0][0])
    let vec = [[[[3]]]]
    assert(1 == #vec)
    assert(1 == #vec[0])
    assert(1 == #vec[0][0])
    assert(1 == #vec[0][0][0])
    assert(3 == vec[0][0][0][0])

    let vec = [
        [[1, 2, 3], [0]],
        [[4, 5, 6], [1]], 
        [[7, 8, 9], [2]],
    ]
}
{
    let vec: [int] = []

    let vec: [[int]] = [[]]
    let vec: [[int]] = [[], []]
    let vec: [[int]] = [[], [], []]

    let vec: [[[int]]] = []
    let vec: [[[int]]] = [[]]
    let vec: [[[int]]] = [[], []]
    let vec: [[[int]]] = [[], [], []]
    let vec: [[[int]]] = [[[]]]
    let vec: [[[int]]] = [[[]], [[]]]
    let vec: [[[int]]] = [[[]], [[]], [[]]]
}
{
    fn test<T>(vec: [[T]], counts: (int, int, int)) {
        assert(counts.0 == #vec[0])
        assert(counts.1 == #vec[1])
        assert(counts.2 == #vec[2])
    }
    test([[1], [2], [3]], (1, 1, 1))
    test([[1], [2], []], (1, 1, 0))
    test([[], [2], [3]], (0, 1, 1))
    test([[1], [], [3]], (1, 0, 1))
    test([[1], [], []], (1, 0, 0))
    test([[], [2], []], (0, 1, 0))
    test([[], [], [3]], (0, 0, 1))

    test([[[1]], [], []], (1, 0, 0))
    test([[], [[2]], []], (0, 1, 0))
    test([[], [], [[3]]], (0, 0, 1))
    test([[[[1]]], [[]], []], (1, 1, 0))
    test([[], [[[2]]], [[]]], (0, 1, 1))
    test([[[]], [], [[[3]]]], (1, 0, 1))

    test([[[1]], [], []], (1, 0, 0))
    test([[], [[2]], []], (0, 1, 0))
    test([[], [], [[3]]], (0, 0, 1))
    test([[[[1]]], [[]], []], (1, 1, 0))
    test([[], [[[2]]], [[]]], (0, 1, 1))
    test([[[]], [], [[[3]]]], (1, 0, 1))

    enum E {X, Y, Z, W}
    test([[E::X, E::Y], [], [E::Z, E::W]], (2, 0, 2))
    test([[[[], [E::X], [E::Y]]], [], [[[E::Z, E::W]]]], (1, 0, 1))
}
{
    assert([1, 2] == [1] + [2] + [])
    assert([1, 3] == [1] + [] + [3])
    assert([2, 3] == [] + [2] + [3])
    assert([1] == [1] + [] + [])
    assert([2] == [] + [2] + [])
    assert([3] == [] + [] + [3])
}
{
    fn check(vec: [[int]]) {
        assert(1 == vec[0][0])
        assert(4 == vec[1][0])
        assert(6 == vec[2][0])
        assert(2 == vec[-3][-2])
        assert(3 == vec[-3][-1])
        assert(5 == vec[-2][-1])
    }
    let vec = [
        [1, 2, 3],
        [4, 5],
        [6],
    ]
    check(vec);

    let vec = [
        [1, 2, 3],
        [4, 5],
        [6],
    ]
    check(vec);

    check([
        [1, 2, 3],
        [4, 5],
        [6],
    ])
}
{
    let vec = [1, 2, 3]
    assert(3 == #vec[0:#vec])
    assert(2 == #vec[0:-1])
    assert(1 == #vec[0:-2])
    assert(0 == #vec[0:-3])
    assert(2 == #vec[1:#vec])
    assert(1 == #vec[2:#vec])
    assert(0 == #vec[3:#vec])
    assert(3 == #vec[:])

    assert(2 == vec[:-1][-1])
    assert(1 == vec[:-2][-1])
    assert(1 == vec[0:][0])
    assert(2 == vec[1:][0])
    assert(3 == vec[2:][0])

    fn func<T>(vec: [T]) -> T {
        assert(#vec > 0)
        return vec[0]
    }
    func([1, 2, 3])
    func([[1], [2, 3], [4, 5, 6]])
    func([[[1]], [[2], [3]], [[4, 5, 6]]])
}
// Equality comparisons (basic types only):
{
    assert([false, true] == [false, true])
    assert([2, 3] == [2, 3])
    assert([4.0, 5.0] == [4.0, 5.0])
    assert(['six', 'seven'] == ['six', 'seven'])

    assert([false, true] != [false, false])
    assert([2, 3] != [2, 2])
    assert([4.0, 5.0] != [4.0, 4.0])
    assert(['six', 'seven'] != ['six', 'six'])

    assert([false, true] != [false])
    assert([2, 3] != [2])
    assert([4.0, 5.0] != [4.0])
    assert(['six', 'seven'] != ['six'])
}
// each vector must have its type inferred at some point before it
// goes out of scope or is used in a type-agnostic way (calling a 
// method like vec.pop(), or even using the '#' operator)
{
    let vec = []
    vec = [0]
    
    let vec = []
    vec = [0]
    vec = [1]

    let vec = []
    vec = []
    vec = [0]

    let test = |vec: [int]| {}
    let a = []
    test(a)

    let test = |vec: [[int]]| {}
    let a = []
    test(a)
    let a = [[]]
    test(a)

    let a = []
    let b = a
    b = [1]
    // type of 'a' inferred from 'b'
    assert(#a == 0)

    let a = []
    let b = a
    b = [1]
    assert(#a == 0)
    a = [2]
    assert(a[0] == 2)

    let a = [[]]
    let b = a
    assert(#a == 1)
    b = [[1]]
    assert(#a == 1)
    assert(#a[0] == 0)
    a = [[2]]
    assert(a[0][0] == 2)

    let a = []
    let b = a
    let c = b
    let d = c
    d = [1]
}

{
    let vec: [int] = []
    _vector_push(vec, 1)
    _vector_push(vec, 2)
    _vector_push(vec, 3)
    assert(vec == [1, 2, 3])
}
{
    let vec = [1]
    _vector_push(vec, 2)
    _vector_push(vec, 3)
    _vector_push(vec, 4)
    assert(vec == [1, 2, 3, 4])
}
{
    let vec = [1, 2, 3]
    assert(3 == _vector_pop(vec))
    assert(#vec == 2)
    assert(2 == _vector_pop(vec))
    assert(#vec == 1)
    assert(1 == _vector_pop(vec))
    assert(#vec == 0)
}
{
    let vec: [int] = []
    _vector_insert(vec, 0, 3)
    _vector_insert(vec, 0, 2)
    _vector_insert(vec, 0, 1)
    assert(vec == [1, 2, 3])
}
{
    let vec: [int] = [1, 2, 3]
    _vector_insert(vec, 1, 4)
    _vector_insert(vec, 3, 5)
    _vector_insert(vec, 5, 6)
    assert(vec == [1, 4, 2, 5, 3, 6])
}

{
    fn check(i: int, j: int, answer: [int]) {
        let vec = [1, 2, 3]
        vec[i:j] = [4, 5, 6]
        assert(vec == answer)
    }
    check(0, 0, [4, 5, 6, 1, 2, 3])
    check(0, 1, [4, 5, 6, 2, 3])
    check(0, 2, [4, 5, 6, 3])
    check(0, 3, [4, 5, 6])
    check(3, 3, [1, 2, 3, 4, 5, 6])
    check(2, 3, [1, 2, 4, 5, 6])
    check(1, 3, [1, 4, 5, 6])
    check(0, 3, [4, 5, 6])
}

{
    fn check(i: int, j: int, answer: [int]) {
        let vec = [1, 2, 3]
        vec[i:j] = vec
        assert(vec == answer)
    }
    check(1, 3, [1, 1, 2, 3])
    check(2, 3, [1, 2, 1, 2, 3])
    check(3, 3, [1, 2, 3, 1, 2, 3])

    check(0, 2, [1, 2, 3, 3])
    check(0, 1, [1, 2, 3, 2, 3])
    check(0, 0, [1, 2, 3, 1, 2, 3])

    check(0, 3, [1, 2, 3])
    check(1, 2, [1, 1, 2, 3, 3])

    let vec = [1, 2, 3, 4, 5]
    vec[1:3] = vec
    assert(vec == [1, 1, 2, 3, 4, 5, 4, 5])
}

{
    fn map<T>(f: fn(T) -> T, vec: [T]) {
        for i = 0, #vec {
            vec[i] = f(vec[i])
        }
    }
    fn times2(i: int) -> int {
        return i * 2
    }
    let v = [1, 2, 3]
    map(times2, v)
    assert(v[0] == 2)
    assert(v[1] == 4)
    assert(v[2] == 6)
    
}

{
    let vec = [1, 2, 3]
    _vector_push(vec, 4)
    _vector_push(vec, 5)
    _vector_push(vec, 6)
    assert(#vec == 6)
    assert(vec[0] == 1)
    assert(vec[5] == 6)
    assert(vec[-6] == 1)
    assert(vec[-1] == 6)
}

{
    let vec: [int] = []
    for i = 0, 100 {
        _vector_push(vec, i)
    }
    assert(#vec == 100)
    for i = 0, 100 {
        assert(i in vec)
    }
    let clone = _vector_clone(vec)
    for i = 0, 50 {
        _vector_erase(vec, i)
    }
    for i = 0, 100, 2 {
        _vector_insert(vec, i, i)
    }
    assert(vec == clone)
}

{
    assert(_vector_clone([1, 2, 3]) == [1, 2, 3])
    assert([1, 2, 3] != [1, 2])
    assert([1, 2, 3] != [1, 2, 4])
}

// Inclusion/contains operator:
{
    assert(3 in [1, 2, 3])
    assert(!(4 in [1, 2, 3]))
}

// Arithmetic on arrays:
{
    assert([] != [1])
    assert([] + [] != [2])
    assert([] + [] + [] != [3])
    assert([1] == [1])
    assert([] + [2] == [2])
    assert([] + [] + [3] == [3])

    assert([] + [1, 2, 3] == [1, 2, 3])
    assert([1] + [2, 3] == [1, 2, 3])
    assert([1, 2] + [3] == [1, 2, 3])
    assert([1, 2, 3] + [] == [1, 2, 3])
    assert([1] + [2] + [3] == [1, 2, 3])
    assert([] + [1] + [2] + [] + [] + [3] + [] == [1, 2, 3])
}
{
    let test = |vec: [int]| {
        assert(#vec == 0)
    }
    test([])
    test([] + [])
    test([] + [] + [])
}

{
    let a = []
    let b = []
    let c = []
    a = b
    b = c
    _vector_push(c, 1)
}
{
    let a = []
    let b = []
    let c = []
    a = b
    b = c
    _vector_push(a, 1)
}

{
    let a = []
    let b = []
    let c = []
    b = a
    c = a
    b = [1]
    assert(a == c)
    assert(a != b)
    assert(b != c)
}
{
    let a = []
    let b = []
    let c = []
    b = a
    c = a
    a = [1]
    assert(#a == 1)
    assert(#b == 0)
    assert(#c == 0)
}

{
    let a = []
    let b = []
    let c = []
    if true {
        // do nothing
    } else {
        _vector_push(a, 1)
    }
    b = c
    c = a
}
{
    let vec = []
    _vector_push(vec, 1)
    assert(vec[0] == 1)
}
{
    let a = []
    let b = a
    _vector_push(b, 1)
    assert(a[0] == 1)
}
{
    fn test<T>(vec: [T], val: T) -> [T] {
        return vec + [val]
    }
    assert([1] == test([], 1))
    assert([1, 2] == test(test([], 1), 2))
    assert([1, 2, 3] == test(test(test([], 1), 2), 3))
}
{
    struct A<T> {
        vec: [T]
    }
    fn test<T>(vec: [T], val: A<T>) -> [T] {
        return vec + val.vec
    }
    let a = A::<int>{vec: [1]}
    assert([1] == test([], a))
    let b = A::<int>{vec: [2, 3]}
    assert([1, 2, 3] == test(test([], a), b))
    let c = A::<int>{vec: [4, 5, 6]}
    assert([1, 2, 3, 4, 5, 6] == test(test(test([], a), b), c))
}
{
    fn test<T>(vec: [T], vec2: [[T]]) {}
    test([], [[1]])
    test([], [[[1]]])
    test([], [[1, 2, 3]])
    test([], [[[1], [2, 2], [3, 3, 3]]])
}
{
    fn test<T>(vec: [T], val: T) -> int {
        _vector_push(vec, val)
        return #vec
    }
    assert(1 == test([], 1))
    assert(1 == test([], test([], 2)))
    assert(1 == test([], test([], test([], 3))))

    let vec = []
    assert(1 == test(vec, 1))
    let vec = []
    assert(2 == test(vec, test(vec, 2)))
    let vec = []
    assert(3 == test(vec, test(vec, test(vec, 3))))
}


//// Slice syntax:
//{
//    fn check(vec: Vector::<int>, begin: int, end: int) {
//        let b = vec[begin:end]
//        begin = begin ?: 0    // vec[None:n] == vec[:n] == vec[0:n]
//        end   = end   ?: #vec // vec[n:None] == vec[n:] == vec[n:#vec]
//        for i = begin, end {
//            assert(vec[i] == b[0])
//            b.pop(0)
//        }
//    }
//    let vec = [1, 2, 3]
//
//    for i = 0, 3 {
//        for j = 0, 3 {
//            check(vec, i, j)
//        }
//    }
//    let result = vec.clone()
//    result.pop()
//    assert(vec[0:-1] == result)
//    result.pop()
//    assert(vec[0:-2] == result)
//    result.pop()
//    assert(vec[0:-3] == result)
//
//    let result = vec.clone()
//    result.pop(0)
//    assert(vec[1:#vec] == result)
//    result.pop(0)
//    assert(vec[2:#vec] == result)
//    result.pop(0)
//    assert(vec[3:#vec] == result)
//
//    let result = vec.clone()
//    result.pop()
//    assert(vec[:-1] == result)
//    result.pop()
//    assert(vec[:-2] == result)
//    result.pop()
//    assert(vec[:-3] == result)
//
//    let result = vec.clone()
//    result.pop(0)
//    assert(vec[1:] == result)
//    result.pop(0)
//    assert(vec[2:] == result)
//    result.pop(0)
//    assert(vec[3:] == result)
//
//    let result = vec.clone()
//    assert(vec[0:] == result)
//    assert(vec[:#vec] == result)
//    assert(vec[:] == result)
//    assert(vec[:1] == [1])
//    assert(vec[1:-1] == [2])
//    assert(vec[-1:] == [3])
//}
