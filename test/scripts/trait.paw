// trait.paw

pub trait InstanceGet {
    fn get(self) -> int;
}

pub trait AssociatedGet {
    fn get_default() -> int;
}

struct Int: InstanceGet + AssociatedGet {
    pub value: int,

    pub fn get(self) -> int {
        self.value
    }

    pub fn get_default() -> int {
        42
    }
}

pub fn test_call_method() {
    let i = Int{value: 123};
    assert(i.get() == 123);
}

fn call_method<Ty: InstanceGet>(t: Ty) -> int {
    t.get()
}

fn call_call_method<Ty: InstanceGet>(t: Ty) -> int {
    call_method(t)
}

pub fn test_indirect_call_method() {
    let i = Int{value: 42};
    assert(call_method(i) == 42);
    assert(call_call_method(i) == 42);
}

pub fn test_call_associated_fn() {
    assert(Int::get_default() == 42);
}

fn call_associated_fn<Ty: AssociatedGet>() -> int {
    Ty::get_default()
}

fn call_call_associated_fn<Ty: AssociatedGet>() -> int {
    call_associated_fn::<Ty>()
}

pub fn test_indirect_call_associated() {
    assert(call_associated_fn::<Int>() == 42);
    assert(call_call_associated_fn::<Int>() == 42);
}

fn call_both_functions<Ty: InstanceGet + AssociatedGet>(t: Ty) -> int {
    t.get() + Ty::get_default()
}

fn call_call_both_functions<Ty: AssociatedGet + InstanceGet>(t: Ty) -> int {
    call_both_functions::<Ty>(t)
}

pub fn test_indirect_call_both_functions() {
    let i = Int{value: 123};
    assert(call_both_functions(i) == 123 + 42);
    assert(call_call_both_functions(i) == 123 + 42);
}


pub trait TestDefault {
    fn default(list: [str]) -> Self;
}

struct DefaultedA: TestDefault {
    pub list: [str],
    pub fn default(list: [str]) -> Self {
        list.push("a");
        Self{list}
    }
}

struct DefaultedB: TestDefault {
    pub list: [str],
    pub fn default(list: [str]) -> Self {
        list.push("b");
        Self{list}
    }
}

struct DefaultedOuter<T: TestDefault> {
    pub fn call_default(list: [str]) {
        // this associated function doesn't mention T in its signature, but uses T
        // inside its body
        let _: T = T::default(list);
    }
}

pub fn test_call_defaulted() {
    let list = [];
    DefaultedOuter::<DefaultedA>::call_default(list);
    DefaultedOuter::<DefaultedB>::call_default(list);
    assert(list[0] == "a");
    assert(list[1] == "b");
}

pub fn test_emit_warning() {
    print("TODO: See trait.paw: monomorphization problem...\n");
}
//// TODO: doesn't work: calls call_defaulted::<DefaultedA>() twice, meaning monomorphization
////       involving trait method calls is likely broken 
//fn call_defaulted<X: TestDefault>(list: [str]) {
//    DefaultedOuter::<X>::call_default(list);
//}
//
//pub fn test_indirect_call_defaulted() {
//    let list = [];
//    call_defaulted::<DefaultedA>(list);
//    call_defaulted::<DefaultedB>(list);
//    assert(list[0] == "a");
//    assert(list[1] == "b");
//}
