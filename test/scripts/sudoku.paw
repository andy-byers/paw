// Translated from from https://github.com/attractivechaos/plb2 (Lua version 
// of sudoku benchmark)

fn sd_genmat() -> ([[int]], [[int]]) {
    let R = [];
    let C = [];
    let r = 0;
    for i = 0, 8 {
        let I = (i / 3) * 27;
        for j = 0, 8 {
            let J = (j / 3) * 9;
            for k = 0, 8 {
                _list_push(C, [ 
                    9 * i + j, 
                    I + J + k + 81,
                    9 * i + k + 162, 
                    9 * j + k + 243, 
                ]);
                r = r + 1;
            }
        }
    }
    for c = 0, 323 { 
        _list_push(R, []);
    }
    for r = 0, 728 {
        for c2 = 1, 4 { 
            _list_push(R[C[r][c2]], r); 
        }
    }
    return (R, C);
}

fn sd_update(
        R: [[int]], 
        C: [[int]], 
        sr: [int], 
        sc: [int], 
        r: int, 
        v: int) -> (int, int)
{
    let min = 10;
    let min_c = 0;
    for c2 = 1, 4 {
        if v > 0 { 
            sc[C[r][c2]] = sc[C[r][c2]] + 128;
        } else {
            sc[C[r][c2]] = sc[C[r][c2]] - 128; 
        }
    }
    for c2 = 1, 4 {
        let c = C[r][c2];
        if v > 0 {
            for r2 = 1, 9 {
                let rr = R[c][r2];
                sr[rr] = sr[rr] + 1;
                if sr[rr] == 1 {;
                    for cc2 = 1, 4 {
                        let cc = C[rr][cc2];
                        sc[cc] = sc[cc] - 1;
                        if sc[cc] < min { 
                            min = sc[cc]; 
                            min_c = cc;
                        }
                    }
                }
            }
        } else {
            for r2 = 1, 9 {
                let rr = R[c][r2];
                sr[rr] = sr[rr] - 1;
                if sr[rr] == 0 {
                    let p = C[rr];
                    sc[p[1]] = sc[p[1]] + 1; 
                    sc[p[2]] = sc[p[2]] + 1; 
                    sc[p[3]] = sc[p[3]] + 1; 
                    sc[p[4]] = sc[p[4]] + 1;
                }
            }
        }
    }
    return (min, min_c);
}

fn byte(s: str) {
    assert(#s == 1);
    if s[0] == '.' {
        return -1;
    } else {
        return _string_parse_int(s, 10);
    }
}

fn sd_solve(R: [[int]], C: [[int]], s: str) -> [[int]] {
    let sr = []; 
    let sc = []; 
    let cr = []; 
    let cc = []; 
    let hints = 0;
    for r = 0, 728 { 
        _list_push(sr, 0);
    }
    for c = 0, 323 { 
        _list_push(sc, 9);
    }
    for i = 0, 80 {
        let t = s[i + 1];
        let a = byte(s[i + 1]);
        if t >= 49 && 
                t <= 57 && 
                t - 49 != 0 {
            a = 1;
        } 
        if a >= 0 { 
            sd_update(R, C, sr, sc, i * 9 + a, 1); 
            hints = hints + 1; 
        }
        cr[i] = 0;
        cc[i] = 0;
    }
    let i = 0;
    let min = 10; 
    let dir = 1; 
    let ret = [];
    while true {
        while i >= 0 && i < 81 - hints {
            if dir == 1 {
                if min > 1 {
                    for c = 0, 323 {
                        if sc[c] < min {
                            min = sc[c]; 
                            cc[i] = c;
                            if min < 2 {
                                break; 
                            }
                        }
                    }
                }
                if min == 0 || min == 10 { 
                    cr[i] = 0;
                    dir = -1; 
                    i = i - 1; 
                }
            }
            let c = cc[i];
            let r2_ = 10;
            if dir == -1 && cr[i] > 0 { 
                sd_update(R, C, sr, sc, R[c][cr[i]], -1); 
            }
            for r2 = cr[i] + 1, 9 {
                if sr[R[c][r2]] == 0 { 
                    r2_ = r2; 
                    break; 
                }
            }
            if r2_ < 10 {
                let T = sd_update(R, C, sr, sc, R[c][r2_], 1);
                min = T.0; 
                cc[i + 1] = T.1;
                cr[i] = r2_;
                dir = 1;
                i = i + 1;
            } else {
                cr[i] = 0;
                dir = -1;
                i = i - 1; 
            }
        }
        if i < 0 { 
            break; 
        }
        let y = [];
        for j = 1, 81 { 
            _list_push(y, s[j] - 48);
        }
        for j = 0, i - 1 {
            r = R[cc[j]][cr[j]];
            y[(r / 9) + 1] = r % 9 + 1;
        }
        _list_push(ret, y);
        dir = -1; 
        i = i - 1;
    }
    return ret;
}

pub fn main() {
    let hard20 = [
        "..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9",
        ".......12........3..23..4....18....5.6..7.8.......9.....85.....9...4.5..47...6...",
        ".2..5.7..4..1....68....3...2....8..3.4..2.5.....6...1...2.9.....9......57.4...9..",
        "........3..1..56...9..4..7......9.5.7.......8.5.4.2....8..2..9...35..1..6........",
        "12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8",
        "1.......2.9.4...5...6...7...5.9.3.......7.......85..4.7.....6...3...9.8...2.....1",
        ".......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....",
        "12.3.....4.....3....3.5......42..5......8...9.6...5.7...15..2......9..6......7..8",
        "..3..6.8....1..2......7...4..9..8.6..3..4...1.7.2.....3....5.....5...6..98.....5.",
        "1.......9..67...2..8....4......75.3...5..2....6.3......9....8..6...4...1..25...6.",
        "..9...4...7.3...2.8...6...71..8....6....1..7.....56...3....5..1.4.....9...2...7..",
        "....9..5..1.....3...23..7....45...7.8.....2.......64...9..1.....8..6......54....7",
        "4...3.......6..8..........1....5..9..8....6...7.2........1.27..5.3....4.9........",
        "7.8...3.....2.1...5.........4.....263...8.......1...9..9.6....4....7.5...........",
        "3.7.4...........918........4.....7.....16.......25..........38..9....5...2.6.....",
        "........8..3...4...9..2..6.....79.......612...6.5.2.7...8...5...1.....2.4.5.....3",
        ".......1.4.........2...........5.4.7..8...3....1.9....3..4..2...5.1........8.6...",
        ".......12....35......6...7.7.....3.....4..8..1...........12.....8.....4..5....6..",
        "1.......2.9.4...5...6...7...5.3.4.......6........58.4...2...6...3...9.8.7.......1",
        ".....1.2.3...4.5.....6....7..2.....1.8..9..3.4.....8..5....2....9..3.4....67.....",
    ];

    let T = sd_genmat();
    let R = T.0;
    let C = T.1;
    let n = 200;
    for i = 1, n {
        for i = 0, #hard20 {
            let l = hard20[i];
            if #l >= 81 {
                let ret = sd_solve(R, C, l);
                for v in ret { 
                    let line = '';
                    for j = 0, #ret {
                        line = line + _int_to_string(v[j]) + ', ';
                    }
                    print(line);
                }
                print('\n');
            }
        }
    }
}
